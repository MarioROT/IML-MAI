# -*- coding: utf-8 -*-
"""FCM.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Foy8B0y_cUJt4dY35DM3ToVa5PUE046C
"""

import numpy as np

class FCM:
  #Define all parameter of the algorithm and give a predefined value to the most common used
    def __init__(self, C, max_iters=100, m=2, eps=0.001):
        self.C = C
        self.max_iters = max_iters
        self.m = m
        self.eps = eps

  #define the main process
    def fit(self, data):
        self.data = data
        self.instances, self.features = data.shape
        #Create the random U matrix the first time that the algorithm runs
        self.memberships = np.random.rand(self.instances, self.C)
        self.centers = np.random.rand(self.C, self.features)

        for _ in range(self.max_iters):
            prev_centers = np.copy(self.centers)

            # Update cluster centers
            self.update_centers()

            # Calculate memberships
            self.update_memberships()

            # Calculate the change in the iteration of new cluster centers
            change = np.sum(np.abs(self.centers - prev_centers))

            if change < self.eps:
                break

    def update_centers(self):
      #With the membership matrix we calculate the centers
        for center in range(self.C):
            numerator = np.sum((self.memberships[:, center] ** self.m).reshape(-1, 1) * self.data, axis=0)
            denominator = np.sum(self.memberships[:, center] ** self.m)
            self.centers[center, :] = numerator / denominator

    def update_memberships(self):
      #given the new centers we can calculate the membership matrix
        distances = np.zeros((self.instances, self.C))
        for value in range(self.C):
            distances[:, value] = np.linalg.norm(self.data - self.centers[value, :], axis=1)

        for i in range(self.instances):
            for j in range(self.C):
                membership_sum = np.sum((distances[i, j] / distances[i, :]) ** (2 / (self.m - 1)))
                self.memberships[i, j] = 1 / membership_sum

    def predict(self):
        return np.argmax(self.memberships, axis=1)